# Room Shapes and Interior Design

## Overview

Rooms in the game are 3D spaces that players can walk through. Initially, rooms are simple 3x3x3 cubes, but the system is designed to support custom room shapes defined by players.

## Design Philosophy

**Start Simple, Plan for Complexity:**
- Initial implementation: 3x3x3 cubes
- Player placed in center of cube
- Simple box geometry
- Plan data structure for custom shapes from the start

**Future Extensibility:**
- Allow players to define custom room shapes
- Support complex geometries
- Room shapes defined by primitives (similar to ship design)
- Or defined by mesh data

## Initial Implementation: 3x3x3 Cubes

### Room Geometry

**Default Room Shape:**
- **Size**: 3 units × 3 units × 3 units
- **Shape**: Cube (box)
- **Player Position**: Center of cube (1.5, 1.5, 1.5)
- **Origin**: Bottom-left-back corner at (0, 0, 0)
- **Bounds**: (0,0,0) to (3,3,3)

### Room Definition

```csharp
room.Properties["roomShape"] = new BsonDocument {
    { "type", "cube" },              // Shape type
    { "size", new BsonDocument {     // For cube: width, height, depth
        { "x", 3.0 },
        { "y", 3.0 },
        { "z", 3.0 }
    }},
    { "playerSpawn", new BsonDocument {  // Where player spawns
        { "x", 1.5 },
        { "y", 1.5 },
        { "z", 1.5 }
    }},
    { "bounds", new BsonDocument {    // Bounding box
        { "min", new BsonDocument { { "x", 0.0 }, { "y", 0.0 }, { "z", 0.0 } } },
        { "max", new BsonDocument { { "x", 3.0 }, { "y", 3.0 }, { "z", 3.0 } } }
    }}
};
```

### Room Rendering (Initial)

**Simple Box:**
```csharp
public class RoomRenderer
{
    public Model RenderRoom(GameObject room, GraphicsDevice device)
    {
        var shape = room.Properties["roomShape"].AsBsonDocument;
        var shapeType = shape["type"].AsString;
        
        if (shapeType == "cube")
        {
            return RenderCubeRoom(shape, device);
        }
        
        // Future: Handle other shape types
        return RenderCustomRoom(shape, device);
    }
    
    private Model RenderCubeRoom(BsonDocument shape, GraphicsDevice device)
    {
        var size = shape["size"].AsBsonDocument;
        var width = size["x"].AsDouble;
        var height = size["y"].AsDouble;
        var depth = size["z"].AsDouble;
        
        // Create box mesh
        var vertices = CreateBoxVertices(width, height, depth);
        var indices = CreateBoxIndices();
        
        // Create vertex buffer
        var vertexBuffer = new VertexBuffer(
            device,
            typeof(VertexPositionNormalTexture),
            vertices.Length,
            BufferUsage.WriteOnly
        );
        vertexBuffer.SetData(vertices);
        
        // Create index buffer
        var indexBuffer = new IndexBuffer(
            device,
            IndexElementSize.ThirtyTwoBits,
            indices.Length,
            BufferUsage.WriteOnly
        );
        indexBuffer.SetData(indices);
        
        return new Model
        {
            VertexBuffer = vertexBuffer,
            IndexBuffer = indexBuffer,
            PrimitiveCount = indices.Length / 3
        };
    }
}
```

### Player Spawn Position

**Default Spawn:**
- Player spawns on floor at center of room
- Y position = floor Y + player height offset
- Can be customized per room
- Stored in `roomShape.playerSpawn`

**Spawn Calculation:**
```csharp
public Vector3 GetPlayerSpawnPosition(GameObject room)
{
    var shape = room.Properties["roomShape"].AsBsonDocument;
    
    if (shape.Contains("playerSpawn"))
    {
        var spawn = shape["playerSpawn"].AsBsonDocument;
        var spawnPos = new Vector3(
            spawn["x"].AsDouble,
            spawn["y"].AsDouble,
            spawn["z"].AsDouble
        );
        
        // Ensure player is on floor
        var floorY = GetFloorY(room, spawnPos);
        var playerHeight = 1.8; // meters
        spawnPos.Y = floorY + (playerHeight / 2.0);
        
        return spawnPos;
    }
    
    // Default: center of bounding box, on floor
    var bounds = shape["bounds"].AsBsonDocument;
    var min = bounds["min"].AsBsonDocument;
    var max = bounds["max"].AsBsonDocument;
    
    var floorY = GetFloorY(room, Vector3.Zero);
    var playerHeight = 1.8; // meters
    
    return new Vector3(
        (min["x"].AsDouble + max["x"].AsDouble) / 2.0,
        floorY + (playerHeight / 2.0),  // On floor
        (min["z"].AsDouble + max["z"].AsDouble) / 2.0
    );
}
```

## Future: Custom Room Shapes

### Shape Types

**Planned Shape Types:**
1. **Cube** (initial) - Simple box
2. **Primitive-Based** - Defined by primitives (like ship design)
3. **Mesh-Based** - Custom mesh from STL file
4. **Procedural** - Generated by algorithm

### Primitive-Based Rooms

**Similar to Ship Design:**
- Rooms can be built from primitives
- Primitives snap together
- 1x1x1 primitive footprint
- Merge meshes for performance

**Room Definition:**
```csharp
room.Properties["roomShape"] = new BsonDocument {
    { "type", "primitive" },
    { "primitives", new BsonArray {
        new BsonDocument {
            { "id", "prim-1" },
            { "modelPath", "/models/primitives/cube.stl" },
            { "position", new BsonDocument { { "x", 0 }, { "y", 0 }, { "z", 0 } } },
            { "rotation", new BsonDocument { { "x", 0 }, { "y", 0 }, { "z", 0 } } },
            { "scale", new BsonDocument { { "x", 1 }, { "y", 1 }, { "z", 1 } } }
        },
        // ... more primitives
    }},
    { "mergedMesh", new BsonDocument {  // Optional: pre-merged mesh
        { "vertices", new BsonArray { /* ... */ } },
        { "indices", new BsonArray { /* ... */ } }
    }},
    { "playerSpawn", new BsonDocument { { "x", 1.5 }, { "y", 1.5 }, { "z", 1.5 } } }
};
```

### Mesh-Based Rooms

**Custom STL Mesh:**
```csharp
room.Properties["roomShape"] = new BsonDocument {
    { "type", "mesh" },
    { "modelPath", "/models/rooms/custom-room.stl" },
    { "scale", new BsonDocument { { "x", 1.0 }, { "y", 1.0 }, { "z", 1.0 } } },
    { "playerSpawn", new BsonDocument { { "x", 0 }, { "y", 1 }, { "z", 0 } } }
};
```

### Procedural Rooms

**Algorithm-Generated:**
```csharp
room.Properties["roomShape"] = new BsonDocument {
    { "type", "procedural" },
    { "algorithm", "cave" },  // or "dungeon", "hallway", etc.
    { "parameters", new BsonDocument {
        { "width", 10.0 },
        { "height", 5.0 },
        { "depth", 10.0 },
        { "complexity", 0.5 }
    }},
    { "playerSpawn", new BsonDocument { { "x", 5 }, { "y", 1 }, { "z", 5 } } }
};
```

## Room Connections: Doors

### Door System

**Automatic Door Generation:**
- When rooms are connected via exits, doors are **automatically generated**
- Doors are placed on the **joining surface** between rooms
- Door position and orientation calculated automatically based on room connection
- Player walks through door to enter next room

**Door Generation Rules:**
1. When an exit connects two rooms, a door is automatically created
2. Door is placed on the surface where rooms join
3. Door orientation matches the connection direction
4. Door size is standardized (configurable per room type)

### Door Definition

**Auto-Generated Properties:**
```csharp
exit.Properties["door"] = new BsonDocument {
    { "autoGenerated", true },  // Automatically generated from room connection
    { "position", new BsonDocument {  // Auto-calculated position on joining surface
        { "x", 1.5 },
        { "y", 0.0 },
        { "z", 0.0 }  // On front wall (for north exit)
    }},
    { "rotation", new BsonDocument {  // Auto-calculated orientation
        { "x", 0 },
        { "y", 0 },
        { "z", 0 }
    }},
    { "size", new BsonDocument {  // Standard door dimensions
        { "width", 1.0 },
        { "height", 2.0 },
        { "depth", 0.1 }
    }},
    { "modelPath", "/models/doors/standard-door.stl" },
    { "open", false },  // Is door open?
    { "locked", false },  // Is door locked?
    { "joiningSurface", "north" }  // Which surface the door is on
};
```

### Automatic Door Placement Algorithm

**Connection Direction → Door Position:**

```csharp
public class DoorGenerator
{
    public BsonDocument GenerateDoor(GameObject exit, GameObject sourceRoom, GameObject destRoom)
    {
        // Get exit direction
        var direction = exit.Properties["direction"].AsString; // "north", "south", "east", "west", "up", "down"
        
        // Get source room bounds
        var sourceBounds = GetRoomBounds(sourceRoom);
        
        // Calculate door position on joining surface
        var doorPosition = CalculateDoorPosition(direction, sourceBounds);
        
        // Calculate door rotation (faces connection direction)
        var doorRotation = CalculateDoorRotation(direction);
        
        // Determine joining surface
        var joiningSurface = GetJoiningSurface(direction);
        
        return new BsonDocument {
            { "autoGenerated", true },
            { "position", doorPosition },
            { "rotation", doorRotation },
            { "size", GetStandardDoorSize() },
            { "modelPath", "/models/doors/standard-door.stl" },
            { "open", false },
            { "locked", false },
            { "joiningSurface", joiningSurface }
        };
    }
    
    private BsonDocument CalculateDoorPosition(string direction, BoundingBox roomBounds)
    {
        // For 3x3x3 cube rooms:
        // - North exit: door on front wall (z = 0), center of wall
        // - South exit: door on back wall (z = 3), center of wall
        // - East exit: door on right wall (x = 3), center of wall
        // - West exit: door on left wall (x = 0), center of wall
        // - Up exit: door on ceiling (y = 3), center
        // - Down exit: door on floor (y = 0), center
        
        var centerX = (roomBounds.Min.X + roomBounds.Max.X) / 2.0;
        var centerY = (roomBounds.Min.Y + roomBounds.Max.Y) / 2.0;
        var centerZ = (roomBounds.Min.Z + roomBounds.Max.Z) / 2.0;
        
        return direction.ToLower() switch
        {
            "north" => new BsonDocument { { "x", centerX }, { "y", 1.0 }, { "z", roomBounds.Min.Z } },
            "south" => new BsonDocument { { "x", centerX }, { "y", 1.0 }, { "z", roomBounds.Max.Z } },
            "east" => new BsonDocument { { "x", roomBounds.Max.X }, { "y", 1.0 }, { "z", centerZ } },
            "west" => new BsonDocument { { "x", roomBounds.Min.X }, { "y", 1.0 }, { "z", centerZ } },
            "up" => new BsonDocument { { "x", centerX }, { "y", roomBounds.Max.Y }, { "z", centerZ } },
            "down" => new BsonDocument { { "x", centerX }, { "y", roomBounds.Min.Y }, { "z", centerZ } },
            _ => new BsonDocument { { "x", centerX }, { "y", 1.0 }, { "z", centerZ } }
        };
    }
    
    private BsonDocument CalculateDoorRotation(string direction)
    {
        // Door rotation to face connection direction
        return direction.ToLower() switch
        {
            "north" => new BsonDocument { { "x", 0 }, { "y", 0 }, { "z", 0 } },      // Faces north
            "south" => new BsonDocument { { "x", 0 }, { "y", 180 }, { "z", 0 } },   // Faces south
            "east" => new BsonDocument { { "x", 0 }, { "y", 90 }, { "z", 0 } },      // Faces east
            "west" => new BsonDocument { { "x", 0 }, { "y", -90 }, { "z", 0 } },    // Faces west
            "up" => new BsonDocument { { "x", -90 }, { "y", 0 }, { "z", 0 } },       // Faces up
            "down" => new BsonDocument { { "x", 90 }, { "y", 0 }, { "z", 0 } },     // Faces down
            _ => new BsonDocument { { "x", 0 }, { "y", 0 }, { "z", 0 } }
        };
    }
    
    private string GetJoiningSurface(string direction)
    {
        return direction.ToLower() switch
        {
            "north" => "north",
            "south" => "south",
            "east" => "east",
            "west" => "west",
            "up" => "ceiling",
            "down" => "floor",
            _ => "unknown"
        };
    }
}
```

### Door Generation on Room Connection

**When Exit is Created:**
```csharp
public void CreateExit(GameObject sourceRoom, GameObject destRoom, string direction)
{
    // Create exit object
    var exit = new GameObject
    {
        Name = $"Exit to {destRoom.Name}",
        Location = sourceRoom
    };
    
    exit.Properties["destination"] = destRoom.Id;
    exit.Properties["direction"] = direction;
    
    // Automatically generate door
    var doorGenerator = new DoorGenerator();
    exit.Properties["door"] = doorGenerator.GenerateDoor(exit, sourceRoom, destRoom);
    
    // Add exit to source room
    sourceRoom.Contents.Add(exit.Id);
    
    // Store exit reference
    if (!sourceRoom.Properties.ContainsKey("exits"))
    {
        sourceRoom.Properties["exits"] = new BsonArray();
    }
    sourceRoom.Properties["exits"].AsBsonArray.Add(exit.Id);
}
```

### Door Updates on Room Changes

**If Room Shape Changes:**
- If room shape is modified, doors may need to be regenerated
- Door positions recalculated based on new room bounds
- Joining surfaces may change

**If Connection Changes:**
- If exit direction changes, door position/rotation updated
- If exit is removed, door is removed
- If exit is added, door is generated

### Door Rendering

**Door as 3D Object:**
- Door is a 3D object in the room
- Automatically positioned on joining surface
- Can be opened/closed (rotation or translation)
- Blocks movement when closed
- Rendered on the surface where rooms connect

**Door Interaction:**
```csharp
public void OpenDoor(GameObject exit)
{
    var door = exit.Properties["door"].AsBsonDocument;
    door["open"] = true;
    
    // Update door model position/rotation
    UpdateDoorModel(exit);
}

public void WalkThroughDoor(GameObject exit, GameObject player)
{
    var door = exit.Properties["door"].AsBsonDocument;
    
    if (!door["open"].AsBoolean)
    {
        notify(player, "The door is closed.");
        return;
    }
    
    if (door["locked"].AsBoolean)
    {
        notify(player, "The door is locked.");
        return;
    }
    
    // Move player to destination room
    var destination = exit.Properties["destination"].AsString;
    MovePlayerToRoom(player, destination);
}
```

### Door Placement Examples

**3x3x3 Cube Room - North Exit:**
- Door on front wall (z = 0)
- Position: (1.5, 1.0, 0.0) - center of wall, 1 unit up from floor
- Rotation: Faces north (0, 0, 0)
- Joining surface: North wall

**3x3x3 Cube Room - East Exit:**
- Door on right wall (x = 3)
- Position: (3.0, 1.0, 1.5) - center of wall, 1 unit up from floor
- Rotation: Faces east (0, 90, 0)
- Joining surface: East wall

**3x3x3 Cube Room - Up Exit:**
- Door on ceiling (y = 3)
- Position: (1.5, 3.0, 1.5) - center of ceiling
- Rotation: Faces up (-90, 0, 0)
- Joining surface: Ceiling

## Room Bounds and Collision

### Bounding Box

**Every Room Has Bounds:**
```csharp
room.Properties["roomShape"]["bounds"] = new BsonDocument {
    { "min", new BsonDocument { { "x", 0.0 }, { "y", 0.0 }, { "z", 0.0 } } },
    { "max", new BsonDocument { { "x", 3.0 }, { "y", 3.0 }, { "z", 3.0 } } }
};
```

**Collision Detection:**
- Player position must be within bounds
- Objects must be within bounds
- Doors must be on room boundary

### Collision Checking

**Position Validation:**
```csharp
public bool IsPositionInRoom(Vector3 position, GameObject room)
{
    var bounds = room.Properties["roomShape"]["bounds"].AsBsonDocument;
    var min = bounds["min"].AsBsonDocument;
    var max = bounds["max"].AsBsonDocument;
    
    return position.X >= min["x"].AsDouble &&
           position.X <= max["x"].AsDouble &&
           position.Y >= min["y"].AsDouble &&
           position.Y <= max["y"].AsDouble &&
           position.Z >= min["z"].AsDouble &&
           position.Z <= max["z"].AsDouble;
}
```

**Object Collision:**
```csharp
public bool CanPlaceObjectAt(Vector3 position, GameObject room, GameObject objectToPlace)
{
    // Check if position is within room bounds
    if (!IsPositionInRoom(position, room))
        return false;
    
    // Check if object is locked
    if (objectToPlace.Properties.ContainsKey("locked") && 
        objectToPlace.Properties["locked"].AsBoolean)
    {
        // Locked objects can't be moved
        return false;
    }
    
    // Check for collisions with other objects
    var objectsInRoom = GetObjectsInRoom(room);
    foreach (var obj in objectsInRoom)
    {
        if (obj.Id == objectToPlace.Id) continue; // Skip self
        
        if (ObjectsCollide(position, objectToPlace, obj))
        {
            return false; // Collision detected
        }
    }
    
    return true;
}

public bool ObjectsCollide(Vector3 pos1, GameObject obj1, GameObject obj2)
{
    var pos2 = GetPosition(obj2);
    var size1 = GetObjectSize(obj1);
    var size2 = GetObjectSize(obj2);
    
    // Simple AABB collision check
    return Math.Abs(pos1.X - pos2.X) < (size1.X + size2.X) / 2.0 &&
           Math.Abs(pos1.Y - pos2.Y) < (size1.Y + size2.Y) / 2.0 &&
           Math.Abs(pos1.Z - pos2.Z) < (size1.Z + size2.Z) / 2.0;
}
```

**Player Movement:**
```csharp
public bool CanMovePlayerTo(Vector3 position, GameObject player, GameObject room)
{
    // Check if position is within room bounds
    if (!IsPositionInRoom(position, room))
        return false;
    
    // Constrain to floor
    var floorY = GetFloorY(room, position);
    position.Y = floorY + GetPlayerHeight(player) / 2.0;
    
    // Check for collisions with objects
    var objectsInRoom = GetObjectsInRoom(room);
    foreach (var obj in objectsInRoom)
    {
        if (PlayerCollidesWithObject(position, player, obj))
        {
            return false; // Collision detected
        }
    }
    
    // Check for collisions with other players
    var playersInRoom = GetPlayersInRoom(room);
    foreach (var otherPlayer in playersInRoom)
    {
        if (otherPlayer.Id == player.Id) continue; // Skip self
        
        if (PlayersCollide(position, player, otherPlayer))
        {
            return false; // Collision detected
        }
    }
    
    return true;
}
```

## Room Objects and Placement

### Object Placement

**Objects in Rooms:**
- **Every object in a room occupies space** within that room
- Objects can be **moved around the room** (unless locked in place)
- Objects can be placed anywhere within room bounds
- Objects can be on floor, walls, ceiling, or floating
- Rooms are **traversable 3D environments**

**Object Position:**
```csharp
object.Properties["position"] = new BsonDocument {
    { "x", 1.0 },
    { "y", 0.5 },  // Vertical position
    { "z", 1.0 }
};

object.Properties["locked"] = false;  // Can be moved
// or
object.Properties["locked"] = true;    // Locked in place
```

**Object Movement:**
- Objects can be moved by players (if not locked)
- Objects can be moved by scripts
- Objects can be moved by physics (if enabled)
- Locked objects cannot be moved

### Gravity and Floor System

**Gravity Simulation:**
- Rooms simulate gravity
- **Players are bound to the floor** (gravity affects players)
- **Objects are placeable** (not bound by gravity, can float)
- Each room defines where the floor is

**Floor Definition:**
```csharp
room.Properties["roomShape"]["floor"] = new BsonDocument {
    { "y", 0.0 },  // Floor is at y = 0
    { "normal", new BsonDocument {  // Floor normal (for non-horizontal floors)
        { "x", 0.0 },
        { "y", 1.0 },
        { "z", 0.0 }
    }}
};
```

**Player Gravity:**
- Players are affected by gravity
- Players are constrained to floor level
- Players cannot float or fly (unless special equipment)
- Player position Y = floor Y + player height offset

**Object Placement (No Gravity):**
- Objects are not affected by gravity
- Objects can be placed anywhere
- Objects can float, be on walls, ceiling, etc.
- Objects can be locked in place

**Floor Calculation:**
```csharp
public double GetFloorY(GameObject room, Vector3 position)
{
    var shape = room.Properties["roomShape"].AsBsonDocument;
    
    // Simple case: horizontal floor
    if (shape.Contains("floor"))
    {
        return shape["floor"]["y"].AsDouble;
    }
    
    // Default: floor at y = 0
    return 0.0;
}

public Vector3 ConstrainPlayerToFloor(GameObject player, GameObject room)
{
    var playerPos = GetPosition(player);
    var floorY = GetFloorY(room, playerPos);
    var playerHeight = 1.8; // meters (configurable)
    
    // Constrain player to floor
    playerPos.Y = floorY + (playerHeight / 2.0);
    
    return playerPos;
}
```

### Object Rendering in Room

**Render All Objects:**
```csharp
public void RenderRoom(GameObject room, GraphicsDevice device)
{
    // Render room geometry
    var roomModel = RenderRoomGeometry(room, device);
    DrawModel(roomModel);
    
    // Render all objects in room (including players)
    var objects = room.Properties["contents"].AsBsonArray;
    foreach (var objId in objects)
    {
        var obj = _objectManager.GetObject(objId.AsString);
        if (obj != null)
        {
            // Get object position (may be moved)
            var position = GetPosition(obj);
            
            // For players: constrain to floor
            if (obj is Player)
            {
                position = ConstrainPlayerToFloor(obj, room);
            }
            
            // Render object at position
            RenderObject(obj, position, device);
        }
    }
    
    // Render doors
    var exits = room.Properties["exits"].AsBsonArray;
    foreach (var exitId in exits)
    {
        var exit = _objectManager.GetObject(exitId.AsString);
        if (exit != null && exit.Properties.ContainsKey("door"))
        {
            RenderDoor(exit, device);
        }
    }
}
```

### Object Movement System

**Moving Objects:**
```csharp
public bool MoveObject(GameObject obj, Vector3 newPosition, GameObject room)
{
    // Check if object is locked
    if (obj.Properties.ContainsKey("locked") && obj.Properties["locked"].AsBoolean)
    {
        return false; // Cannot move locked object
    }
    
    // Validate new position
    if (!CanPlaceObjectAt(newPosition, room, obj))
    {
        return false; // Invalid position or collision
    }
    
    // Update object position
    SetPosition(obj, newPosition);
    
    // Notify clients of position change
    NotifyObjectMoved(obj, newPosition);
    
    return true;
}

public bool MovePlayer(GameObject player, Vector3 newPosition, GameObject room)
{
    // Constrain player to floor
    var floorY = GetFloorY(room, newPosition);
    var playerHeight = GetPlayerHeight(player);
    newPosition.Y = floorY + (playerHeight / 2.0);
    
    // Validate new position
    if (!CanMovePlayerTo(newPosition, player, room))
    {
        return false; // Invalid position or collision
    }
    
    // Update player position
    SetPosition(player, newPosition);
    
    // Notify clients of position change
    NotifyPlayerMoved(player, newPosition);
    
    return true;
}
```

**Locking Objects:**
```csharp
public void LockObject(GameObject obj, bool locked = true)
{
    obj.Properties["locked"] = locked;
    
    if (locked)
    {
        // Object is now locked in place
        // Cannot be moved by players or scripts
    }
    else
    {
        // Object is now unlocked
        // Can be moved freely
    }
}
```

## Implementation Phases

### Phase 1: Simple Cubes (Initial)

**Tasks:**
1. Add `roomShape` property to Room class
2. Default all rooms to 3x3x3 cube
3. Define floor (y = 0 for initial cubes)
4. Set player spawn on floor at center
5. Render rooms as simple boxes
6. Basic collision (bounds checking)
7. **Object placement system** (objects occupy space, can be moved)
8. **Gravity system** (players bound to floor, objects not)
9. **Object locking** (objects can be locked in place)
10. **Automatic door generation** when rooms are connected
11. Door placement on joining surfaces
12. Door rendering in rooms

**Deliverables:**
- All rooms are 3x3x3 cubes
- Floor defined (y = 0)
- Player spawns on floor at center
- Room rendering works
- Basic bounds checking
- **Objects can be placed and moved in rooms**
- **Players bound to floor (gravity)**
- **Objects not bound by gravity (placeable)**
- **Objects can be locked in place**
- **Doors automatically generated on room connections**
- Doors placed on joining surfaces
- Doors rendered correctly

### Phase 2: Custom Shapes (Future)

**Tasks:**
1. Support primitive-based rooms
2. Support mesh-based rooms
3. Support procedural rooms
4. Room shape editor
5. Advanced collision (mesh-based)

**Deliverables:**
- Players can define custom room shapes
- Multiple shape types supported
- Room shape editor UI
- Advanced collision detection

## Data Structure Integration

### GameObject Properties

**Room-Specific Properties:**
```csharp
room.Properties["roomShape"] = new BsonDocument {
    // Shape definition (see above)
};

room.Properties["lighting"] = new BsonDocument {
    // Lighting data (from DATA_STRUCTURE.md)
};

room.Properties["contents"] = new BsonArray {
    // Object IDs in room
};

room.Properties["exits"] = new BsonArray {
    // Exit IDs (doors)
};
```

### Room Class Extension

**Helper Methods:**
```csharp
public static class RoomHelpers
{
    public static Vector3 GetPlayerSpawn(GameObject room)
    {
        // Get spawn position
    }
    
    public static BoundingBox GetBounds(GameObject room)
    {
        // Get room bounds
    }
    
    public static bool IsPositionInRoom(Vector3 position, GameObject room)
    {
        // Check if position is in room
    }
    
    public static Model GetRoomModel(GameObject room, GraphicsDevice device)
    {
        // Get room geometry model
    }
}
```

## Client-Side Rendering

### Room Scene

**Room Rendering Pipeline:**
1. Load room shape definition
2. Generate/load room geometry
3. Apply room materials/textures
4. Render room geometry
5. Render objects in room
6. Render doors
7. Apply lighting
8. Render player

**Scene Graph:**
```
Room
├── Geometry (room shape)
├── Objects
│   ├── Object 1
│   ├── Object 2
│   └── ...
├── Doors
│   ├── Door 1
│   ├── Door 2
│   └── ...
└── Player
```

## Notes

- **Initial Simplicity**: Start with 3x3x3 cubes, works for MVP
- **Future Flexibility**: Data structure supports custom shapes from day one
- **Consistency**: Room shapes use same primitive system as ship design
- **Performance**: Simple cubes are fast, custom shapes can be optimized
- **Player Experience**: Simple cubes are easy to understand, custom shapes add depth

## Related Documentation

- [DATA_STRUCTURE.md](../pivot/DATA_STRUCTURE.md) - GameObject 3D properties
- [SPACE_MECHANICS.md](./SPACE_MECHANICS.md) - Dual-space system
- [SHIP_DESIGN.md](./SHIP_DESIGN.md) - Primitive system (similar approach)
- [MODEL_FORMAT.md](../pivot/MODEL_FORMAT.md) - STL model format
